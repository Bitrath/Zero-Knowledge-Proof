\documentclass[10pt]{article}
\usepackage[margin=1.3in]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx, enumitem, lipsum, setspace, amsmath, verbatim}
\usepackage[dvipsnames]{xcolor}
\usepackage{csquotes}

\title{\textit{Zero Knowledge Proof} \\ Fundamentals and Applications}
\author{Nicolò Zarulli \\ matricola 296235}
\date{a.a. 2021-2022 - Università di Parma}

\begin{document}
% --- Title ----
\maketitle

% --- Abstract / Introduction ---
\begin{abstract}
Questo documento vuole essere un contenitore di informazioni relative all'approccio crittografico \textit{Zero Knowledge Proof}. Nasce come mia personale necessità di raggruppare un insieme di ottime fonti ed informazioni, all'interno di uno stesso documento leggibile e coerente. Conseguentemente la struttura dello stesso sarà molto semplice ed intuitiva: vi saranno dei \textit{capitoli} e delle \textit{sezioni} interne per approfondire determinati argomenti e dettagli dello stesso. Per ora, data inizio Marzo 2022, seguirò una stesura che va di pari passo al mio lavoro di ricerca svolto nel \textit{Dipartimento di Ingegneria dell'Informazione} presso l'Università di Parma, con un attento riguardo verso una traduzione in tesi di laurea triennale.
\end{abstract}

% --- Zero Knowledge Proof ---
\section{Zero Knowledge Proof}
La \textit{Dimostrazione a Conoscenza Zero} o \textit{Zero Knowledge Proof} è un approccio/sistema crittografico attraverso il quale un entità detta \textbf{Prover} è in grado di dimostrare di essere in possesso di un \textbf{\textit{Informazione}} o \textbf{\textit{Witness}} ad un altra entità detta \textbf{Verifier}, senza però rivelarne il contenuto e senza rivelarne alcuna conoscenza a riguardo. 
	% --- FIGURE 1 ---
E' generalmente considerato un \textbf{Interactive Verification Protocol}  in quanto richiede un interazione diretta tra i due enti comunicanti; si vedrà più avanti che in certi ambiti questo tipo di implementazione può risultare poco conveniente, indirizzando lo sguardo e l'interesse verso un implementazione asincrona detta \textit{Non Interactive}.

% --- SUB /  La Struttura ---
\subsection{ZKP: La Struttura}
Come ogni protocollo richiede, devono essere stabiliti dei parametri e delle regole che le entità in comunicazione devono seguire e rispettare. Un generico protocollo a Zero Knowledge può essere visto come un semplice algoritmo che vede l'implementazione di 3 fasi sequenziali. Queste sono necessarie per stabilire un terreno di \textit{gioco} equo e coerente sia rispetto al Prover che rispetto al Verifier. Per introdurre queste fasi, bisogna prima capire quando è utile implementare un protocollo ZKP: 
\begin{itemize}
	\item il Prover conosce un segreto, per il quale vi è una ricompensa in gioco. Egli, prima di rivelare il segreto, vuole ottenere la ricompensa.
	\item il Verifier, colui che ha messo in palio la ricompensa, vuole accertarsi che il Prover conosca effettivamente il segreto. Prima di pagare la ricompensa, vuole vedere il segreto stesso.
\end{itemize}
Entrambe le entità non intendono mettere a rischio la loro integrità prima di aver ricevuto una prova concreta, sia essa il segreto o la ricompensa. Grazie alla filosofia della dimostrazione a Zero Knowledge, un certo Prover è in grado di dimostrare al Verifier di possedere un certo segreto, senza però rivelargli nulla di esso. Per poter arrivare a questo grado di certezza entrambe le entità dovranno seguire un algoritmo, costituito da tre passi:
\begin{enumerate}
	\item \textbf{Witness Phase}: Il Prover computa una dimostrazione, detta \textbf{Proof}, sulla base di un \textbf{segreto} e contenente uno \textit{Statement}. Questa viene inviata al Verifier, che potrà analizzarla per capire la validità del Prover.
	\item \textbf{Challenge Phase}: Ottenuto il Proof, il Verifier inizia a fare delle domande al Prover. Queste permettono al Verifier di capire se il Prover sia onesto o malizioso.
	\item \textbf{Response Phase}: Il Prover riceve le \textit{domande} dal Verifier e per ognuna di queste ne formula una risposta. Il Verifier, nel complesso, valuta le risposte per prendere una decisione definitiva, accettando o rifiutando il Proof ricevuto nella Witness Phase.
\end{enumerate}
E' importante evidenziare delle conseguenze:
\begin{itemize}
	\item Se il Prover conosce veramente il segreto, riuscirà sempre a fornire risposte convincenti al Verifier. Altrimenti avrà, nel breve termine, una certa probabilità di riuscire ad ingannarlo, mentre a lungo andare non riuscirà a convincerlo.
	\item Se dopo una prima esecuzione dell'algoritmo il Verifier non risulta convinto, può ritornare alla Challenge Phase.
	\item Il lavoro computazionale delle entità potrebbe essere oneroso, dipende dai meccanismi usati per implementare le fasi.
	\item Nelle fasi descritte \textbf{nessun tipo di informazione privata verrà condivisa}.
\end{itemize}

% --- SUB / SUB /  Un Esempio Astratto ---
\subsubsection{Un Esempio Astratto}
Per comprendere al meglio questo tipo di approccio crittografico, è molto efficace presentare al lettore una storia molto conosciuta che evidenzia con gran chiarezza la crittografia a Zero Knowledge. I due interlocutori saranno:
\begin{itemize}
	\item \textbf{Bob}: colui che ha scoperto un certo segreto. Bob sarà il Prover.
	\item \textbf{Alice}: colei che garantisce una ricompensa per la rivelazione del segreto. Alice sarà il Verifier.
\end{itemize}
\textit{"Bob ha scoperto la parola segreta per aprire la porta in una caverna. La caverna ha una forma circolare con l'entrata da un lato e la porta che blocca l'altro lato. Alice dice a Bob che lo pagherà per il segreto, ma non prima di essere sicura che lui lo conosca davvero. Bob si dice d'accordo a rivelargli il segreto, ma non prima di aver ricevuto i soldi. Pianificano quindi uno schema con il quale Bob potrà dare prova ad Alice di conoscere la parola ma senza rivelargliela:
\begin{enumerate}
	\item Alice aspetta fuori all'entrata mentre Bob entra nella caverna; Bob sceglie uno dei due sentieri da percorrere tra A e B per raggiungere la porta. [\textbf{Witness Phase}]
	\item Alice entra nella caverna e grida a Bob il nome del sentiero con il quale dovrà tornare all'entrata. [\textbf{Challenge Phase}]
	\item Se Bob conosce la parola segreta, riuscirà sempre ad aprire la porta e ritornarne da Alice con il sentiero richiesto. [\textbf{Response Phase}]
\end{enumerate} \textbf{Se Bob appare in modo affidabile probabilmente conosce veramente il segreto.}" 
 } \\ \\
Se si ipotizza che \textbf{Bob conosca veramente la parola magica}, è facile: se necessario apre la porta e ritorna attraverso il sentiero desiderato. È da notare che Alice non conosce il sentiero con il quale Bob ha raggiunto la porta.
Se si ipotizza però che \textbf{Bob non conosca il segreto}, egli avrebbe il 50\% di possibilità di ritornarne con il sentiero richiesto da Alice, per ogni prova effettuata. Seguendo il \textit{principio della probabilità ad eventi indipendenti}, la possibilità che Bob riesca ad adempire correttamente a tutte le richieste di Alice \textbf{senza conoscere il segreto} diventa statisticamente molto piccola (circa 0.01\%). Al contrario, se Bob risponde in modo affidabile ad ogni evento imposto da Alice, lei potrà essere statisticamente convinta che Bob sia effettivamente in possesso del segreto (circa 99.99\%).
	% --- FIGURE 2 --- 

% --- SUB /  Le Proprietà ---
\subsection{ZKP: Le Proprietà}
La nozione di \textit{Zero Knowledge} fu introdotta negli anni '80 da un gruppo di ricercatori del MIT (\textit{Goldwasser, Micali, Rackoff}) e descrive in modo molto più approfondito i concetti brevemente descritti nelle sezioni precedenti.
Attraverso un \textbf{Interactive Proof System} viene definito un modello dove un Provider scambia dei messaggi con un Verifier per convincerlo che un certo \textit{Mathematical Statement} in suo possesso sia vero. Un aspetto molto importante, evidenziato dai ricercatori, riguarda una proprietà di integrità sullo scambio stesso dei messaggi tra le due entitò comunicanti. E' possibile che un Prover malizioso tenti di ingannare un Verifier onesto nel credere ad uno statement falso. In questo modello difatti il Prover è un entità in una posizione avvantaggiata, \textit{ha tutto da guadagnare e nulla da perdere}.  Questo è un punto fondamentale nello studio di questo determinato approccio crittografico, a riguardo anche ad una possibile implementazione su sistemi informatici veri e propri. I ricercatori MIT sollecitarono l'attenzione anche verso una situazione opposta e assolutamente \textbf{non trascurabile}: \textit{"E se un Prover onesto non si potesse fidare di un Verifier, in questo caso, malizioso?"}. Questa situazione concerne il problema dell'\textbf{\color{teal} information leakage}: si parla del comprendere di quanto dettaglio (informazioni extra) ha effettivamente bisogno il Verifier durante la fase di valutazione di un Proof ricevuto.
Entrambi i lati del protocollo (Prover \& Verifier) necessitano di \textbf{sicurezze} sulle intenzioni dell'altra entità in comunicazione. Vi è la necessità di introdurre delle \textbf{proprietà fondamentali} che ogni \textit{Zero Knowledge Protocol} deve possedere ed implementare:
\begin{itemize}
	\item[\textbf{Completeness}] (completezza): Se lo \textit{statement} del Proof è veritiero, un Prover onesto riuscirà sempre a convincere un Verifier altrettanto onesto. La probabilità non corrisponderà mai al 100\%, ma l'obiettivo è quello di avvicinarsi il più possibile.
	\item[\textbf{Soundness}] (solidità/correttezza): Se lo \textit{statement} del Proof è falso, nessun Prover malizioso potrà convincere un Verifier onesto che l'affermazione sia vera; la probabilità di riuscire di convincerlo è resa il più bassa possibile, tenendo conto dei meccanismi utilizzati per implementare il protocollo.
	\item[\textbf{Zero Knowledge}] (conoscenza zero): E' la proprietà che da il nome all'approccio crittografico e garantisce che il Prover non condivida troppe informazioni, anche sensibili, ad un Verifier (onesto o disonesto che sia). Se lo statement risulta veritiero, nessun Verifier disonesto potrà sapere altro che tale informazione. 
\end{itemize}

% --- SUB / SUB /  Un Esempio Tecnico ---
\subsubsection{Un Esempio Tecnico}
In questo caso l'impostazione del modello è la seguente:
\begin{itemize}
	\item Un Prover conosce un certo numero segreto \textit{S} e vuole dimostrarlo ad un Verifier.
	\item Alla base del meccanismo di generazione del Proof, della computazione di una risposta da parte del Prover e del meccanismo di validazione degli statement da parte del Verifier, vi è l'\textbf{aritmetica modulare}.
\end{itemize}
L'esecuzione del protocollo vedrà le fasi introdotte in precedenza, con l'aggiunta di una quarta fase (\textit{Verification Phase}) a carico del Verifier. \\ \\

% --- Esecuzione Esempio con Formule ---
\textbf{Esecuzione}
\begin{enumerate}
	\item \textbf{Witness Phase}: Il Prover computa uno \textbf{statement personale v} 
	\[
		v = s^2 (mod n) \quad \textrm{con} \quad n=p q \quad \textrm{e}  \quad \sqrt{n} \leq s \leq n-1 \quad \textrm{e}  \quad s \neq (p \wedge q)
	\]
	L'avversario non può estrarre il segreto \textit{s} dal numero computato \textit{v}. \\  I numeri \textit{p} e  \textit{q} sono due  \textit{large private primes}, ossia il risultato della moltiplicazione di due numeri primi. \\
	Il Prover sceglie un intero randomico \textit{r} in \( \big(1 \leq r \leq n-1 \big) \) e computa 
	\[
		x = r^2 (mod n) \qquad \textrm{dove x rappresenta uno \textbf{statement pubblico}}
	\]
	ed infine invia \textit{x} al Verifier.
	
	\item \textbf{Challenge Phase}: Il Verifier sceglie
	\[
	\textrm{un bit } \alpha \in  \big\{ 0,1 \big\}
	\]
	e lo invia al Prover. \\
	Ogni bit descrive una challenge differente da proporre al Prover.
	\item \textbf{Response Phase}: In base al bit \(\alpha\) ricevuto, il prover svolgerà una challenge differente:
	\begin{itemize}
		\item[Se \( \alpha = 0\)]: il Prover imposta il Proof come
		\[
		\textrm{\textbf{Proof}} \quad \varphi = r
		\]
		\item[Se \( \alpha = 1\)]: il Prover computa il Proof come
		\[
		\textrm{\textbf{Proof}} \quad \varphi = r s (mod n)
		\]
	\end{itemize}
	Successivamente invia il Proof  \(\varphi\) al Verifier.
	
	\item \textbf{Verification Phase}: Il Verifier valida il Proof \(\varphi\) ricevuto dal Prover. Se vale  
	\[
		\varphi^2 = x(v^\alpha) (mod n)
	\]
	allora accetta il \(\varphi\) ricevuto. \\
	Decide poi se inoltrare una nuova \textit{challenge} al Prover o confermare che quest'ultimo conosce effettivamente il segreto. \\
\end{enumerate} 
\newpage
\textbf{Risultati}
\\ \\ Questa implementazione verifica le proprietà chiave di ogni ZKP:
\begin{itemize}
	\item[\textbf{Completeness}]: Presupponendo che il \textit{segreto s} conosciuto dal Prover sia \textit{vero},  egli riesce sempre ad inoltrare un Proof (
	\( 
		\varphi = r \quad \textrm{o} \quad  \varphi = r s (mod n)
	\)
	) corretto al Verifier, dato che può computare senza problemi lo \textit{statement x}.
	\item[\textbf{Soundness}]: Se il Prover non conosce il \textit{segreto s} reale, ad ogni \textit{challenge} ricevuta dal Verifier avrà il 50\% di probabilità di inviargli un Proof \(\varphi\) corretto, ossia che riesca a passare la \textit{Validation Phase}. Al contrario, il Verifier rifiuterà il Proof \(\varphi\) fornito dal Prover sempre con una probabilità del 50\%, per ogni evento effettuato. E' quindi un modello molto simile al problema della caverna; un Prover malizioso non riuscirà ad ingannare per sempre un Verifier onesto. \\
Se \(\varphi\) è verificato \textit{T} volte, la probabilità del Prover di ingannare il Verifier risulta
\[
	P(E) = (\frac{1}{2})^T
\]
con l'evento \(\big\{E: \textrm{Il Prover inganna il Verifier senza conoscere il \textit{segreto s}} \big\}\)
\item[\textbf{Zero Knowledge}]: Il Verifier conosce solamente i numeri \textit{v, x, \(\varphi\)}, per ogni esecuzione del protocollo. Il Prover ha la garanzia di poter mantenere private le sue informazioni sensibili, ma soprattutto, ha la sicurezza, grazie all'aritmetica modulare, che il Verifier non possa risalire al suo \textit{segreto s} conoscendo solamente i valori da egli forniti.
\end{itemize}
Grazie all'implementazione di queste tre proprietà, sia un Prover che un Verifier onesto sono protetti da attacchi maliziosi.

% --- SUB / Classificazione ---
\subsection{ZKP: Classificazione}
Gli esempi di Zero Knowledge Proof illustrati nelle sezioni precedenti richiedono l'interazione diretta tra le due entità comunicanti, attraverso lo schema di \textit{domande \& risposte}. Ne risalta un'importante parametro: l'\textbf{interazione}.
Tramite questo si può evidenziare una classificazione dei protocolli a Zero Knowledge:
\begin{itemize}
	\item \textbf{Interactive Zero Knowledge Proofs}: si basano su una \textit{comunicazione sincrona} e diretta tra i due enti comunicanti. In questo modello, il Verifier metterà a disposizione del Prover una serie di \textit{task} o azioni, che dovrà risolvere per dimostrare di possedere realmente un Witness o segreto. Generalmente il lavoro del Prover risulta computazionalmente più oneroso, in base al meccanismo/algoritmo richiesto per risolvere i task richiesti. 
	\item \textbf{Non-Interactive Zero Knowledge Proofs}: In questo caso non vi è la necessità di avere un interazione diretta tra Prover e Verifier; la \textit{validazione} del \textit{proof} fornito dal Prover può essere sostenuta ad uno stage più avanzato, anche da un terzo ente fidato. Questa tipologia di ZKP può richiedere l'utilizzo di \textit{software} e \textit{risorse} addizionali, ed utilizza una comunicazione \textit{asincrona} tra Prover e Verifier.
\end{itemize}
	% --- FIGURE 3 --- 

% --- SUB / SUB / Interactive ZKP ---
\subsubsection{Un piccolo approfondimento: Interactive-ZKP}
Agli albori dello sviluppo dei Zero Knowledge Proof, il modello più diffuso era di tipo \textit{Interactive-ZKP}, vedendone un implementazione soprattutto nei sistemi informatici, basandosi su di un approccio \textit{matematico} piuttosto che astratto ed applicativo. 
In questo caso \textit{ZKP} viene utilizzato per dimostrare a qualcuno la conoscenza di un fatto \textit{matematico}, senza rivelarne però nessun informazione sensibile dello stesso. In tempi recenti l'applicazione di questo tipo di approccio crittografico viene vista ed utilizzata principalmente nei sistemi distribuiti, soprattutto nell'ambito delle \textit{blockchain}. Per questioni di prestazioni, sicurezza ed evoluzione del modello si tende a preferire la tipologia  \textit{Non Interactive ZKP}. E' comunque importante evidenziare certi casi nei quali è consigliato un approccio interattivo:
\begin{itemize}
	\item \textbf{Knowledge of a three-coloring graph}: è un problema molto richiesto in ambito delle telecomunicazioni dove il modello si basa sulla teoria dei grafi. Sia il Prover che il Verifier conoscono un certo grafo pubblico: il Prover vuole dimostrare di possedere un algoritmo che permette di ottenere un'istanza dello stesso grafo ma a 3 colori, dove ogni nodo ne tocca almeno un altro con un colore differente dal suo. Da questo tipo di problema ne deriva un modello non-interactive ampiamente utilizzato in blockchain: il \textbf{zkSnark}.
	% --- FIGURE 4 ---
	\item \textbf{Knowledge of a discrete logarithm of some residue module p}: dato un numero primo pubblico \textit{g} detto \textit{generatore}, un numero primo pubblico \textit{p} detto \textit{modulo} e un certo \textit{residuo r}, conosco un certo valore \textit{x} tale che 
	\( 
	\quad g^x = y (mod p)
	\)
	 , che è a tutti gli effetti la definizione di \textit{logaritmo discreto}.
	 \item \textbf{Knowledge of a private key corresponding to a publicly-known public key}
\end{itemize}

% --- SUB /  Modelli di Implementazione ---
\subsection{ZKP: Modelli di Implementazione}
L'approccio della Dimostrazione a Conoscenza Zero trova grande applicazione nell'era del digitale e delle comunicazioni Internet ma, soprattutto, nella categoria dei \textit{Sistemi Distribuiti} con particolare riferimento alle \textit{Blockchain}. Come illustrato, vi sono vari modelli e varie filosofie di implementazione di questo tipo di sistema crittografico; è utile introdurre e studiare diversi modelli ZKP pensati per un implementazione concreta. Questi modelli possono far parte della filosofia \textit{Interactive ZKP} o della \textit{Non-Interactive ZKP}.

% --- SUB /  SUB / zkSNARK ---
\subsubsection{zkSNARK}
Il modello zkSnark, acronimo di \textit{zero knowledge Succinct Non-interactive ARgumentoof Knowledge}, è un modello ZKP di tipo Non-Interactive il quale introduce una nuova proprietà: la \textbf{sinteticità} (\textit{succinctness}). Questa sposta l'obiettivo del modello verso una migliore implementazione a livello di \textit{complessità}, quindi di un attento riguardo verso il dispendio computazionale delle risorse in gioco.  Il modello zkSnark coinvolge tre entità: un \textbf{Prover P}, un \textbf{ Verifier V} ed un terzo ente fidato detto \textbf{Setup S}. Quest'ultimo avrà il compito di generare una coppia di chiavi, necessarie a P e a S per poter, rispettivamente, generare un \textit{proof \(\pi\)} ed effettuarne la verifica dello stesso. Ciò che è importante evidenziare in zkSnark sono le seguenti caratteristiche:
\begin{enumerate}
	\item La \textit{Verification Phase} è eseguita in un breve \textit{running time}.
	\item La dimensione del proof \(\pi\) è di soli pochi bytes.
	\item Il Prover ed il Verifier non sono obbligati a comunicare in modalità \textit{sincrona}.
	\item Il proof \(\pi\) può essere verificato da un qualsiasi Verifier, secondo una filosofia di tipo \textbf{off-line way}.
	\item L'algoritmo che il Prover P dovrà eseguire appartiene alla \textbf{classe di complessità NP}.
\end{enumerate}
Queste caratteristiche verranno approfondite nel capitolo successivo, dedicato interamente al modello zkSnark. \\ \\
% --- zkSNARK Table ---
\begin{tabular}{ | | c | c | | }
\hline
\multicolumn{2}{ | | c | |}{\textbf{zkSnark Requirements}} \\
\hline \hline \hline
\textbf{Trusted Setup} & Required \\
 \hline
\textbf{Prover Algorithm} & \(O(nlogn)\) \\ 
 \hline
\textbf{Verifier Algorithm} & \(O(1)\) \\ 
 \hline
\textbf{Proof Size / Communication complexity} & \(O(1)\) \\
 \hline
\textbf{Implementation Technique} & Quadratic Arithmetic Programs \\
\hline
\end {tabular}
	% --- FIGURE 5 ---

% --- SUB /  SUB / Ben-Sasson's Model ---
\paragraph{Ben-Sasson's Model \\} 
Basandosi su zkSnark, \textit{Ben-Sasson et al.} proposero un nuovo modello zkSnark per circuiti aritmetici, incentrando il loro obiettivo nello scindere in due processi indipendenti la creazione di una coppia di chiavi dalla validazione di un proof tra due entità; questo modello vede quindi la distinzione tra una \textbf{off-line phase} ed una \textbf{on-line phase}. Dato che si basa su zkSnark, anche questo modello vede l'utilizzo di \textbf{NP-Statements}, i quali sono istanze di \textbf{NP-Problems} che possono essere verificate/provate seguendo le proprietà di \textit{Zero Knowledge}. 
\begin{itemize}
	\item[\textbf{Off-line Phase}]: Il Setup S in questo caso viene sostituito da un \textit{zkSnark key generator}, il quale prende in ingresso un \textit{circuito universale}, otteunuto da un programma generatore di circuiti a partire da tre vincoli strutturali usati come input: un \textbf{program size bound}, \textbf{input size bound} ed un \textbf{time bound}. Il \textit{zkSnark KG} genera la coppia di chiavi (PK, VK) a partire dal circuito universale ottenuto.
	\item[\textbf{On-line Phase}]:  Un Prover P computa un certo \textit{proof \(\pi\)} a partire da un \textit{circuito assegnato} e dalla chiave PK ricevuta dallo \textit{zkSnark KG} della \textit{off-line phase}. Il Circuito è il risultato della computazione di una certa \textit{Witness map}, la quale rappresenta la conoscenza del segreto da parte di P.
	\par Un Verifier V riceve un certo \textit{proof \(\pi\)} da un Prover. Deciderà se accettarlo o rifiutarlo usando la chiave VK ricevuta dallo \textit{zkSnark KG}.
\end{itemize}
Il vantaggio di questo modello vede l'aggiunta di un ulteriore livello di integrità e privacy a riguardo della generazione di una coppia di chiavi (PK, VK) coinvolte nella \textit{generazione/validazione} di un  \textit{proof \(\pi\)}. \\
	% --- FIGURE 6 ---
	
% --- SUB /  SUB / Ligero ---
\subsubsection{Ligero}
Ligero è un modello che propone un \textit{argomento interattivo a zero knowledge} che vuole essere più compatto. La sua caratteristica principale è quella di non avere bisogno di un \textit{trusted setup} tra i due enti comunicanti. Fu introdotto in una pubblicazione scientifica scritta da \textit{Ames Scott et al.} e risalente al 2017. 
Il vantaggio di questo protocollo vede l'implementazione di un argomento a zero knowledge partendo sempre da problemi NP la cui complessità computazionale risulta proporzionale alla radice quadrata della dimensione del circuito di verifica dell'argomento stesso. Inoltre, Ligero può essere costruito a partire da una qualsiasi \textbf{funzione di hashing collision-resistant}. Alternativamente, può essere reso \textit{non-interactive} se basato sul modello \textbf{random-oracle}: 
\begin{displayquote}
Un modello random-oracle è utilizzato per modellare funzioni crittografiche di hashing all'interno di schemi dove sono necessarie delle forti assunzioni di randomicità sull'output della stessa funzione hash. Un \textbf{random-oracle} o \textit{scatola nera}, è una funzione matematica che associa ogni possibile domanda ad una risposta casuale, scelta uniformemente all'interno del suo dominio di output.
\end{displayquote}
Ligero riesce quindi ad implementare con gran efficenza e concretezza degli argomenti zkSNARK che non richiedono la presenza di un \textbf{trusted setup} o \textbf{public key cryptosystem}. Questo li rende estremamente efficaci in presenza di circuiti di verifica ad ampie dimensioni. \\ \\
% --- Ligero Table ---
\begin{tabular}{ | | c | c | | }
\hline
\multicolumn{2}{ | | c | |}{\textbf{Ligero Requirements}} \\
\hline \hline \hline
\textbf{Trusted Setup} & Not Required \\
 \hline
\textbf{Prover Algorithm} & \(O(n logn)\) \\ 
 \hline
\textbf{Verifier Algorithm} & \(O(n)\) \\ 
 \hline
\textbf{Proof Size / Communication complexity} & \(O(\sqrt{n})\) \\
 \hline
\textbf{Implementation Technique} & Interactive Oracle Proofs \\
\hline
\end {tabular}

% --- SUB /  SUB / Bulletproofs ---
\subsubsection{Bulletproofs}
Bulletproofs è un modello di dimostrazione a zero knowledge che è strutturato sul problema del logaritmo discreto e fu introdotto da \textit{Bunz et al.} in una pubblicazione scientifica apposita. Questo modello è stato pensato per migliorare la natura distribuita e trustless delle Blockchains, dando la possibilità di apportare sostanziali miglioramenti sulla sicurezza e confidenzialità delle transazioni in criptovalute.
Per ottenere questi risultati, il modello è strutturato come un \textit{Non-Interactive Zero Knowledge Proof} protocol che garantisce una dimensione contenuta dei \textit{proof} e che non richiede un \textit{setup fidato}. I Bulletproofs migliorano di molto la dimensione lineare,  contenuta in \textit{n}, dei proof normalmente utilizzati in transazioni confidenziali per Bitcoin e altre criptovalute. Inoltre, i Bulletproofs supportano una funzione molto importante e che riguarda il concetto di \textit{range proofs}: il \textit{multi-party computation ( MPC ) }protocol, che permette di aggregare i proof di un party di entità in un unico proof risultante, il quale non permette di rivelare nessun informazione dei segreti dei proof contenuti. I Bulletproofs sono costruiti sulla tecnina EUROCRYPT 2016, sempre formulata dal gruppo di ricercatori a capo del progetto. In poche parole, questi sono i punti chiave che questo modello introduce: 
\begin{itemize}
	\item Short zero-knowledge proofs for general arithmetic circuits, based on the discrete logarithm assumption without a trusted setup.
	\item Extremely efficient range proofs implemented via the MPC protocol.
	\item Applications focused onto an improving transaction confidentiality for the Blockchain environment. \\
\end{itemize}

% --- Bulletproofs Table ---
\begin{tabular}{ | | c | c | | }
\hline
\multicolumn{2}{ | | c | |}{\textbf{Bulletproofs Requirements}} \\
\hline \hline \hline
\textbf{Trusted Setup} & Not Required \\
 \hline
\textbf{Prover Algorithm} & \(O(c)\) \\ 
 \hline
\textbf{Verifier Algorithm} & \(O(c)\) \\ 
 \hline
\textbf{Proof Size / Communication complexity} & \(O(\log{n})\) \\
 \hline
\textbf{Implementation Technique} & Discrete Logarithm \\
\hline
\end {tabular}

% --- SUB / ZKP Applicazioni ---
\subsection{ZKP: Le Applicazioni}
Una parte importante di questo studio non riguarda solo la comprensione della letteratura e dei principali meccanismi di ZKP, bensì è fondamentale cercare di delineare delle aree nelle quali possa essere realmente applicato per averne un uso pratico. L'obiettivo di un applicazione pratica del protocollo riguarda principalmente la \textbf{protezione della privacy dei dati durante uno scambio di messaggi}. Oggigiorno sono presenti vari scenari nei i quali risulta conveniente implementare un certo tipo di approccio a Zero Knowledge, tali: 
\begin{itemize}
	\item \textbf{Blockchain}: Il livello di trasparenza che viene offerto da Blockchain pubbliche tali \textit{Bitcoin} o \textit{Etheruem} granatisce la possibilità di portare avanti un certo tipo di validazione delle transazioni in modo pubblico. Questo si può però tradurre in perdita di privacy per gli utenti coinvolti nelle transazioni validate. L'utilizzo dei protocolli a Zero Knowledge Proof permette quindi di stabilire un maggiore livello di privacy per gli utenti e dati coinvolti in  Blochckain pubbliche. Un esempio è la criptovaluta \textit{Zcash}, che pubblica le transazioni su di una Blockchain pubblica ma vede l'implementazione di zkSNARK per offrire una maggiore protezione sui dati sensibili della transazione e degli utenti.
	\item \textbf{Finance}: Il Gruppo Bancario ING ha introdotto un modello di ZKP che si basa sul concetto di \textit{range}, detto \textbf{ZKRP}: questo permette ai suoi clienti di poter dimostrare di essere in possesso di un numero segreto contenuto in un raggio d'azione predefinito. Un semplice esempio applicativo di questo modello potrebbe offrire la possibilità ad un cliente della Banca che vuole prendere a carico un Mutuo, di dimostrare di percepire uno stipendio che possa sostenere i pagamenti, senza però rivelare la cifra esatta alla Banca.
	\item \textbf{Anonymous Verifiable Online Voting}: Il concetto di \textbf{votazione} è una componente fondamentale per garantire democrazia, sia essa nei confronti di una Nazione o di una Società di Partecipazione. Nel caso la votazione sia strutturata via sistemi informatici, una problematica potrebbe riguardare la privacy degli elettori, i quali potrebbero essere coinvolti in una fuga di dati sensibili durante la votazione stessa, perdendo la proprietà di anonimato. Potrebbe anche risultare molto complicato portare avanti in modo sicuro il processo di verificazione del risultato della votazione. ZKP è una possibile soluzione per garantire un terreno equo e di anonimato in un processo di votazione. Basandosi sulla struttura di ZKP, degli elettori idonei posso esprimere una votazione con confidenzialità e garantendo il loro anonimato. E' anche possibile permettere agli elettori di richiedere, all'istituzione responsabile della votazione, un Proof verificabile per avere dimostrazione che il loro voto è presente nell'urna finale, decisiva per la votazione. 
	\item \textbf{Authentication}: ZKP può essere utilizzato per il processo di autenticazione di utenti senza scambiare informazioni segrete e sensibili come  ad esempio possono essere le password. Un esempio di applicazione può riguardare un tipo di athenticazione remota e biometrica.
	\item \textbf{Secure Remote Biometric Authentication}: L'autenticazione biometrica remota è un metodo che può essere utilizzato per identificare il login di un certo utente attraverso le sue caratteristiche biometriche, tali:  impronte digitali, immagini del viso, dell'iride o il riconoscimento di pattern vascolari. ZKP potrebbe essere implementato per risolvere un problema di sicurezza nella privatizzazione e confidenzialità dei dati inoltrati ad un third party non fidato per effettuare l'autenticazione. 
	\item \textbf{Machine Learning}: ZKP può permette al proprietario di un certo algoritmo di Machine Learning di convincere altri utenti sui risultati ottenuti dal modello, senza rivelare nessuna informazione sensibile sul modello stesso.
\end{itemize}
Si può quindi dire che, analizzando brevemente queste soluzioni tramite ZKP per problemi reali, il principale campo di lavoro dell'approccio crittografico riguarda la privatizzazione e confidenzialità di un certo segreto sensibile durante una comunicazione tra due o più entità.

% --- zkSNARK ---
\section{zkSnark: \textit{zero knowledge Succint Non-Interactive Argument of Knowledge}}
Questo protocollo vede l'implementazione del modello di Zero Knowledge \textit{Non-Interactive} e si basa sulla teoria dei grafi detta \textit{SNARK (Succint Non Interactive Argument Of Knowledge)}. Uno snark è un grafo cubico connesso, privo di ponti, con indice cromatico uguale a 4.
% --- MINI PAGE with FIGURE 7 ---
 In altre parole, uno \textbf{snark} è un grafo in cui ogni vertice ha tre nodi vicini, basandosi sulla condizione che gli spigoli non possono essere colorati solo con tre colori senza che due spigoli dello stesso colore si incontrino in un punto. La filosofia zkSnark venne introdotta nel 2012 in un articolo pubblicato da \textit{Bitanksy Nir}. Una prima implementazione fu integrata nel protocollo \textit{\textbf{Zerocash blockchain}}, divenendo la colonna portante del lavoro computazionale svolto per ottenere una validazione sull'aggiunta di blocchi, introducendo la possibilità ad un certo party di creare e gestire dei \textbf{mathematical proofs} per dimostrare di possedere o meno un certo tipo di informazione, senza rinunciare alla sua integrità.
 
 % --- SUB / La Struttura ---
\subsection{zkSNARK: La Struttura}
Essendo un modello Non-Interactive, l'interazione tra Prover e Verifier viene gestita da un terzo ente fidato ad entrambi detto \textit{setup}. Il setup mette a disposizione del protocollo dei circuiti e software aggiuntivi com aiuto alla dimostrazione. Nel caso di zkSnark, il modello vede la presenza di tre enti in comunicazione asincrona: un \textbf{Prover P}, un \textbf{Verifier V} ed un \textbf{Setup S}. Viene introdotto l'utilizzo di una coppia di chiavi, dette \textbf{Proving Key [PK]} e \textbf{Validation Key [VK]}, necessarie a P ed S per scambiare dei messaggi:
\begin{itemize}
	\item[\textbf{Proving Key, PK}]: utilizzata da P per computare un \textit{proof \(\pi\)} verificabile. 
	\item[\textbf{Validation Key, VK}]: utilizzata da V per verificare un \textit{proof \(\pi\)} generato da P attraverso PK. 
\end{itemize}
Queste chiavi sono generate e distribuite da S attraverso un algoritmo di \textit{Generazione KG}, il quale prende in ingresso due parametri: un valore predefinito di sicurezza \(\lambda\) ed un \textit{F-arithmetic circuit C}. 
Il modello definisce \textbf{tre algoritmi indipendenti}, destinati alle entità del protocollo:
\begin{itemize}
	\item[+]\textbf{Key Generator KG [Setup]}: \(KG(\lambda, C)\)
	\item[+]\textbf{Proof Generator PG [Prover]}: \(PG(PK, x, W)\)
	\item[+]\textbf{Proof Validator PV [Verifier]}: \(PV(VK, x, \pi)\)
\end{itemize}
% --- MINI PAGE LEGENDA ---
\setlength\fboxrule{1.2pt}
\fbox{\begin{minipage}{\textwidth}
Legenda: \raggedright \\
\(\lambda\): \textit{parametro di sicurezza} \raggedleft \\ 
\(\textrm{C}\): \textit{circuito aritmetico con input ed output \(\in\) campo F} \raggedleft \\
PK: \textit{proving key, PK \(\in F\)} \raggedleft \\
VK: \textit{validation key, VK \(\in F\)} \raggedleft \\
x: \textit{input pubblico di P, hashed value x} \(\in F^n\) \raggedleft \\
W: \textit{input segreto di P,  witness value w} \(\in F^h\) \raggedleft \\
\(\pi\): \textit{proof generato da P, proof value } \(\pi \in F^h\) \raggedleft \\
\end{minipage}}
	% --- FIGURE 8 ---

 % --- SUB / Le Entità ---
\subsection{zkSNARK: Le Entità}
Data la natura del modello, è importante scindere i ruoli delle tre entità in gioco per definire ed analizzare gli algoritmi che verranno eseguiti ad ogni livello della comunicazione.
\begin{itemize}
	\item[\textbf{Setup S}]: il compito di S è quello di generare una coppia unica di chiavi \textit{(PK,VK)} da distribuire ad un P ed un V, in modo che possano comunicare tra loro per eseguire una verifica a Zero Knowledge. Egli esegue l'algoritmo di Key Generator \(KG(\lambda, C)\), a partire da un parametro \(\lambda\) sicuro e sconosciuto sia a P che a V. Quindi: 
	\[
	\textrm{(PK, VK)} = KG(\lambda, C)
	\]
	con 
	\textit{C F-arithmetic circuit};
		 \(\textrm{PK, VK} \in F\);
		 \textit{F è un Field/Campo}.
	\par L'introduzione di questo ente terzo e fidato è fondamentale: permette di tenere privato il parametro di sicurezza  \(\lambda\); tramite questo vi è la possibilità di eseguire l'algoritmo KG per la generazione di chiavi. Se \(\lambda\) fosse conosciuto da P od S, verrebbero introdotte delle problematiche di integrità della comunicazione stessa. Si possono quindi analizzare due situazioni differenti che descrivono questa falla di sistema, risolta dall'affidamento ad S l'esecuzione dell'algoritmo KG:
	\begin{itemize}
		\item[V esegue KG]: se V ha il compito di eseguire KG, avrà anche il compito di scegliere casualmente il parametro di sicurezza \(\lambda\) per creare la coppia di chiavi. In questo schema il problema si focalizza sul mantenimento dell'integrità di \(\lambda\) da parte di V: se P fosse in grado di conoscere od ottenere \(\lambda\) usato da V per la comunicazione instaurata, sarebbe in grado lui stesso di generare {\color{red}fake proofs}.
		\item[P esegue KG]: al contrario, se un Prover P avesse il compito di generare una coppia di chiavi per la comunicazione, un verifier V onesto non potrebbe mai accettare da P nessun \(\pi\) \textit{proof} ricevuto, dato che è P a scegliere il parametro \(\lambda\), avendo la possibilità di cambiarlo per generare proofs maliziosi.
	\end{itemize} 
	\par La soluzione vive quindi nel mezzo: \textbf{\textit{"il generatore di chiavi KG viene affidato ad un entità/gruppo fidato sia per P che per V. In questo modo il parametro \(\lambda\) sarà nascosto ad entrambi, rimanendo privato e conosciuto solo al third party. Quest'ultimo avrà quindi il compito di generare e distribuire a P e V una coppia di chiavi (PK, VK), da utilizzare appositamente per la verifica di certo un segreto W partendo da un circuito aritmetico prestabilito C."}}
	\item[\textbf{Prover P}]: partendo da una chiave PK ricevuta da S, genera un \textbf{proof \(\pi\)}, tale che: 
	\[ \pi = PG(PK, x, W)\]
	con \(PK \in F, \quad x \in F^n, \quad W \in F^h\). \\
	Questo proof generato viene inviato a V e dimostra che P consce un \textit{witness/segreto W} e che questo witness soddisfa il \textit{circuito aritmetico C} conosciuto. Di fatti, il circuito aritmetico C definisce un certo \textbf{programma}, tale che: 
	\[C( x, W) = 0^l\]
	Il risultato di C, può essere visto come un valore \textit{booleano} che descrive la validità di un certo \textit{segreto W} attraverso il circuito aritmetico stesso computando un \textbf{messaggio} in uscita dallo stesso. Questa nozione è fondamentale a livello del Verifier V.
	
	\item[\textbf{Verifier V}]: riceve un certo \textbf{proof \(\pi\)} da P e, partendo dalla chiave VK ricevuta da S, computa la verifica di \(\pi\) ricevuto tramite l'algoritmo PV, tale che:
	\[PV(VK, x, \pi) = True/False\] 
	allora, \( \quad PV(VK, x, \pi) == ( \exists W \mid C(x, W)) \)
\end{itemize}

% --- SUB / La Complessità --- 
\subsection{zkSnark: La Complessità}
Conoscendo la definizione delle proprietà fondamentali dei protocolli a Zero Knowledge, è intuibile come zkSNARK verifichi con facilità ognuna di queste: completeness, solidity e zero-knowledge. Questo protocollo non solo si distingue dagli altri per la necessità di dover coinvolgere un terzo ente nella dimostrazione, bensì introduce una nuova proprietà che ridefinisce lo standard dei Zero Knowledge Proofs: la \textit{sinteticità} o \textbf{succinctness}. Essa descrive principalmente le caratteristiche del modello a livello di spesa computazionale; per parlare quindi della sinteticità di zkSNARK si deve fare un passo indietro e capire di cosa tratta l'insiemistica di problemi che questo protocollo utilizza: si parla della classe di problemi \textit{NP}.

% --- SUB / SUB / Problemi NP --- 
\subsubsection{Non Deterministic Polynomial Problems}
Un problema di ottimizzazione \textit{R} fa parte della classe \textit{Non Deterministic Polynomial (NP)} quando nota la sua soluzione ottima, il valore ottimo del problema può essere calcolato in un tempo polinomiale. Per descrivere il lato "non deterministico" di questa classe di problemi, viene particolarmente utile la definizione rivista utilizzando il concetto di \textit{Macchine di Turing}: 

\begin{displayquote}
Un problema di ottimizzazione appartiene alla classe di complessità NP quando le sue soluzioni ottime possono essere verificate in un tempo polinomiale con una Macchina di Turing \textit{non deterministica}, ossia che in presenza di un determinato stato e un determinato carattere letto, la macchina permette più operazioni/transizioni in contemporanea.
\end{displayquote}

Questa rappresenta una categoria molto ampia di problemi di ottimizzazione: non importa con che complessità un algoritmo ci porti ad una soluzione ottima del problema, basta che il valore ottimo ricavato a partire da questa soluzione sia in un tempo polinomiale. Diverso è invece per i problemi della classe \textit{Polynomial (P)}, i quali richiedono che esista un algoritmo \textit{A} che risolve il problema di ottimizzazione in un tempo strettamente polinomiale. E' comunque importante evidenziare una relazione tra queste due classi di problemi:
\(P \in NP\). Se un problema appartiene alla classe P, egli farà parte anche della classe NP; non vale il viceversa.
Quando si parla, generalmente, di Zero Knowledge Proof si sta analizzando una primitiva crittografica che si basa sulla computazione di un \textit{NP-Statement}, ossia un'istanza di un certo problema NP. La maggior parte dei protocolli a Zero Knowledge sono quindi costruiti sulla classe di problemi NP, mettendo a disposizione un'ampia varietà di algoritmi tramite i quali si possa sviluppare un modello in base alle proprie esigenze. Seguendo questa introduzione, si può dire che:  
\begin{displayquote}
Un Prover P intende dimostrare ad un Verifier V che è in possesso di una valida Soluzione W di un \textit{NP-Problem pubblico} ma senza rivelare nulla della soluzione stessa. Essa viene dimostrata grazie alla computazione, da parte di P, di un NP-Statement, il quale verrà poi verificato in tutta sicurezza da V.
\end{displayquote}

% --- SUB / SUB /  Succinctness --- 
\subsubsection{Succinctness}
La sintenticità, \textit{succinctness}, richiede che il proof utilizzato dal modello sia \textbf{compatto} e \textbf{facilmente} verificabile. Questa proprietà risulta fondamentale ogniqualvolta un modello prevede un tipo di comunicazione \textbf{costosa} in termini di risorse, oppure quando il Verifier risulta debole a livello di risorse di computazione. Per i motivi citati nella sezione precedente, vi è particolare interesse nel utilizzare problemi della classe NP per modelli che prevedano l'implementazione della proprietà di sinteticità. Questo anche perché la Classe NP risulta contenere la maggior parte di problemi reali e di ottimizzazione, tali: 
\begin{itemize}
	\item Boolean Satisfaction ( NP-complete \(\subset\) NP )
	\item Polynomial Time on a Deterministic Turing Machine ( \textbf{sorting} ) : la classe NP contiene problemi che sono infatti risolvibili su una macchina di Turing ( non deterministica ) in tempo esponenziale o più veloce se possibile.
\end{itemize}
Allora quando si dice che 
\begin{displayquote}
un NP-Statement può essere provato in Zero Knowledge 
\end{displayquote}
vuol dire che una qualsiasi istanza di un problema NP può essere verificata in Zero Knowledge.
\textbf{Gli zkSNARKs sono un esempio di NP-Statement}. \\

% --- zkSNARK Table ---
\begin{tabular}{ | | c | c | | }
\hline
\multicolumn{2}{ | | c | |}{\textbf{zkSnark Complexity Requirements}} \\
\hline \hline \hline
\textbf{Prover Algorithm} & \(O(nlogn)\) \\ 
 \hline
\textbf{Verifier Algorithm} & \(O(1)\) \\ 
 \hline
\textbf{\color{Red}Proof Size / Communication complexity} & \(\color{Red}O(1)\) \\
 \hline
\textbf{Implementation Technique} & Quadratic Arithmetic Programs \\
\hline
\end {tabular}


% --- Zero Knowledge Proof nella Blockchain --- 
\section{Zero Knowledge Proof in Blockchain}




\end{document}